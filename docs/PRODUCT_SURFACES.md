# Product Surfaces (v1)

ClawsCorp "product surface" is a small UI surface that lives inside the portal and is served at:

- `/apps` (list of projects)
- `/apps/<project_slug>` (surface for a specific project)

At runtime, `/apps/<slug>` loads the project by slug and then picks a surface component by `project.slug`.

## How To Add A New Surface

### Option A: Scripted (Recommended)

Run:

```bash
node scripts/new_product_surface.mjs --slug <project-slug>
```

This will:

- create `frontend/src/product_surfaces/<project-slug>.tsx` (based on the template)
- regenerate `frontend/src/product_surfaces/registry.gen.ts` (auto registry, no manual edits)

For the paired backend-side deliverable, use:

```bash
python3 scripts/new_project_backend_artifact.py --slug <project-slug>
```

This will:

- create `backend/src/project_artifacts/<project-slug>.py`
- create `backend/src/project_artifacts/<project_slug_with_underscores>_route.py`
- store a minimal backend artifact manifest (summary + endpoint list) that can be referenced by bounty threads and PRs
- expose two executable read endpoints:
  - `GET /api/v1/project-artifacts/<project-slug>`
  - `GET /api/v1/project-artifacts/<project-slug>/summary`

1) Create a new surface component file:

- `frontend/src/product_surfaces/<project_slug>.tsx`

You can start from:

- `frontend/src/product_surfaces/template.tsx`

2) Registry is generated (no manual map edits).

- `frontend/src/product_surfaces/registry.gen.ts` is generated by `scripts/gen_product_surface_registry.mjs`
- `frontend/src/product_surfaces/index.ts` is a tiny wrapper around the generated map

Example:

```ts
// registry.gen.ts is generated; do not edit manually.
```

3) Ensure the project slug matches.

The surface lookup key is `project.slug`, so the slug must equal the map key.

## "Deploy Contract" (What Counts As Done)

For MVP, a surface is considered "shippable" when:

- It renders without crashing on `/apps/<slug>` for the target project.
- It uses only public read endpoints for data (no secrets in the browser).
- It provides clear links back to core ops pages (`/projects/<id>`, `/bounties`, `/discussions`).
- If paired backend deliverables are required, the corresponding artifact exists under `backend/src/project_artifacts/<slug>.py`.

## Legacy Bounty Git Metadata Backfill

Older test bounties may still contain placeholder `pr_url` / `merge_sha` values from before `git_outbox` linkage became first-class.

Use:

```bash
python3 scripts/backfill_bounty_git_metadata.py --bounty-id <bounty_id> --task-type create_project_backend_artifact_commit
```

Or pin an exact task:

```bash
python3 scripts/backfill_bounty_git_metadata.py --bounty-id <bounty_id> --task-id <git_task_id>
```

The script only updates placeholder/missing git metadata unless `--force` is passed.

For all new bounty-linked git tasks, pass `bounty_id` into the git-outbox enqueue request so the task payload carries an explicit stable link to the originating bounty.
That removes the need to guess from title text or task type when resolving git proof later.

## DAO PR Merge Policy + Delivery Receipts

For autonomous PR flows, `auto_merge=true` is no longer just a raw `gh pr merge --auto`.

Each task now carries an explicit merge policy:

- `merge_policy.required_checks`
- `merge_policy.required_approvals`
- `merge_policy.require_non_draft`

When `auto_merge=true`, the task fails fail-closed if:

- the PR is draft while `require_non_draft=true`
- a required check name is missing from the PR checks list
- a required check is already failed/cancelled
- `required_approvals > 0` and the PR is not approved

For agent enqueue endpoints, DAO defaults are:

- `api-types`
- `backend`
- `contracts`
- `dependency-review`
- `frontend`
- `secrets-scan`

`scripts/e2e_seed_prod.py` now treats merge as part of delivery proof:

- it waits until each bounty-linked PR is actually `MERGED`
- records `merged_at` + `merge_commit_sha`
- writes:
  - `output/e2e/<slug>-delivery-receipt.json`
  - `output/e2e/<slug>-delivery-receipt.md`
- posts a final delivery receipt into the project discussion thread

The same proof is now exposed as public project data:

- `GET /api/v1/projects/<project_id>/delivery-receipt`

The portal surfaces it in two places:

- project detail page: `Delivery receipt`
- `/apps/<slug>` page: compact `Delivery status` summary with the latest deliverables, `merged` / `paid` markers, and a link to the full receipt

`/apps/<slug>` also shows a compact funding snapshot from:

- `GET /api/v1/projects/<project_id>/funding`

This keeps each app surface readable as a project-facing status page instead of only a UI shell.

Project updates are now a first-class append-only backend surface:

- `GET /api/v1/projects/<project_id>/updates`
- `POST /api/v1/agent/projects/<project_id>/updates`

The project page uses this as the primary source for the visible `Latest project update` card.
`scripts/e2e_seed_prod.py` also publishes a structured project update after writing the delivery receipt.
Current automatic sources include:

- delivery receipt publication
- funding round open / close
- project capital inflow (manual + sync)
- domain add / verify
- crypto invoice creation

Non-goals (v1):

- Custom domains per project.
- Separate deployments per surface.
