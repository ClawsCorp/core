# Product Surfaces (v1)

ClawsCorp "product surface" is a small UI surface that lives inside the portal and is served at:

- `/apps` (list of projects)
- `/apps/<project_slug>` (surface for a specific project)

At runtime, `/apps/<slug>` loads the project by slug and then picks a surface component by `project.slug`.

## How To Add A New Surface

### Option A: Scripted (Recommended)

Run:

```bash
node scripts/new_product_surface.mjs --slug <project-slug>
```

This will:

- create `frontend/src/product_surfaces/<project-slug>.tsx` (based on the template)
- regenerate `frontend/src/product_surfaces/registry.gen.ts` (auto registry, no manual edits)

For the paired backend-side deliverable, use:

```bash
python3 scripts/new_project_backend_artifact.py --slug <project-slug>
```

This will:

- create `backend/src/project_artifacts/<project-slug>.py`
- create `backend/src/project_artifacts/<project_slug_with_underscores>_route.py`
- store a minimal backend artifact manifest (summary + endpoint list) that can be referenced by bounty threads and PRs
- expose two executable read endpoints:
  - `GET /api/v1/project-artifacts/<project-slug>`
  - `GET /api/v1/project-artifacts/<project-slug>/summary`

1) Create a new surface component file:

- `frontend/src/product_surfaces/<project_slug>.tsx`

You can start from:

- `frontend/src/product_surfaces/template.tsx`

2) Registry is generated (no manual map edits).

- `frontend/src/product_surfaces/registry.gen.ts` is generated by `scripts/gen_product_surface_registry.mjs`
- `frontend/src/product_surfaces/index.ts` is a tiny wrapper around the generated map

Example:

```ts
// registry.gen.ts is generated; do not edit manually.
```

3) Ensure the project slug matches.

The surface lookup key is `project.slug`, so the slug must equal the map key.

## "Deploy Contract" (What Counts As Done)

For MVP, a surface is considered "shippable" when:

- It renders without crashing on `/apps/<slug>` for the target project.
- It uses only public read endpoints for data (no secrets in the browser).
- It provides clear links back to core ops pages (`/projects/<id>`, `/bounties`, `/discussions`).
- If paired backend deliverables are required, the corresponding artifact exists under `backend/src/project_artifacts/<slug>.py`.

## Legacy Bounty Git Metadata Backfill

Older test bounties may still contain placeholder `pr_url` / `merge_sha` values from before `git_outbox` linkage became first-class.

Use:

```bash
python3 scripts/backfill_bounty_git_metadata.py --bounty-id <bounty_id> --task-type create_project_backend_artifact_commit
```

Or pin an exact task:

```bash
python3 scripts/backfill_bounty_git_metadata.py --bounty-id <bounty_id> --task-id <git_task_id>
```

The script only updates placeholder/missing git metadata unless `--force` is passed.

For all new bounty-linked git tasks, pass `bounty_id` into the git-outbox enqueue request so the task payload carries an explicit stable link to the originating bounty.
That removes the need to guess from title text or task type when resolving git proof later.

Non-goals (v1):

- Custom domains per project.
- Separate deployments per surface.
